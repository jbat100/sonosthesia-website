
.container

    p.quotation (Under construction...)

    h1 Interactive Digital Arts

    p The idea of interactive digital art is not new. It essentially emerged as soon as computer technology allowed it to, continuing a tradition of audio/visual art which preceded it in spirit but was neither digital nor interactive. It was elegantly formulated by Golan Levin on the #[a(href="http://acg.media.mit.edu/people/golan/aves/") Audiovisual Environment Suite] website, a project which goes back to the year 2000.

    div.container
        p.quotation "The Audiovisual Environment Suite [...] allows people to create and perform abstract animation and synthetic sound in real time. [It] attempts to design an interface which is supple and easy to learn, yet can also yield interesting, infinitely variable and personally expressive performances in both the visual and aural domains. Ideally, these systems permit their interactants to engage in a flow state of pure experience. [It is] built around the metaphor of an inexhaustible and dynamic audiovisual substance, which is freely deposited and controlled by the user's gestures. Each instrument situates this substance in a context whose free-form structure inherits from the visual language of abstract painting and animation. The use of low-level synthesis techniques permits the sound and image to be tightly linked, commensurately malleable, and deeply plastic."

    p An extended discussion of the audio/visual arts tradition as well as considerations for a new interface metaphor for digital media, and descriptions of substantial list of important works in the domain can be read in Golan Levin's #[a(href="http://www.flong.com/texts/publications/thesis/") Masters Thesis]. This vision is central to Sonosthesia. We aim to create inter-modal control flows where content generated in different forms of media, by different software components, affect each other in real-time, as well as being influenced by user input in powerfully expressive ways. As computer technology and interaction techniques evolve the possibilities for the real-time creation of complex audio/visual content grow with it, and although a number of projects have since continued Golan's work, opportunities provided by a new generation of tools seem to be yet untapped.


    h1 Standards for Control Data

    p A central concept of Sonosthesia cross-modal control flow between components. Components can react to control input and produce control output. Creating a reference for domain specific control data to allow compatibility between different components is an important step, depending on the type of component this control data will take different forms. Digital art often uses the open-ended OSC protocol, which is very flexible but lack the kind of standardised semantics enforced by older protocols such as MIDI. OSC also lacks data structuring (maps, arrays etc...) and does not allow bi-directional messaging patterns, both of which Sonosthesia as shown a need for.

    p JSON has been chosen for data representation as it combines flexibility and structure with an explicit, self-documenting human readable format. It is also transport-independent and its capacity for handling a wide variety of messaging patterns is well tested. There might be some over-head in terms of size but with modern hardware, the effect will be insignificant unless unreasonable message densities are used.

    h2 Factory Control Data

    p A useful generic concept is that of a factory, which #[b creates], #[b controls] and #[b destroys] products. This applies for example to MIDI (where the products are notes) as we will see in the next section, but also to other areas relating to virtual environments. In its generic form the factory messaging pattern looks like this. First we create an object, on a given channel, with a given identifier, and associated parameters.

    :markdown
        ```javascript
            {
                "type": "factory/create",
                "channel": "channel1",
                "identifier": "123e4567-e89b-12d3-a456-426655440000",
                "parameters": {
                    "parameter1": "something",
                    "parameter2": 0.5433435
                }
            }
        ```

    p The channel is user defined, it represents an object generator. Each channel defines the set of parameters it supports. The identifier looks deliberately machine-generated, users don't care about it, it is just a key for future control and destruction. Now that the object is created, we can control any set of its parameters

    :markdown
        ```javascript
            // control parameters for an object, given its identifier
            {
                "type": "factory/control",
                "identifier": "123e4567-e89b-12d3-a456-426655440000",
                "parameters": {
                    "parameter2": 0.3039989
                }
            }

            // control parameters multiple objects, given their identifier
            {
                "type": "factory/control",
                "identifier": ["123e4567-e89b-12d3-a456-426655440000", "42665544-e89b-12d3-a456-123e45670000"],
                "parameters": {
                    "parameter2": 0.3039989
                }
            }

            // control parameters for all objects on a given channel
            {
                "type": "factory/control",
                "channel": "channel1",
                "parameters": {
                    "parameter2": 0.3039989
                }
            }
        ```

    p Note in the first two examples, the channel is not specified, the unique object identifier is associated with it so it would be redundant information. If the channel is specified as in the third example, the control applies to all objects on the channel, also specifying an identifier is an invalid message. When the time comes to destroy the object, the same referencing (identifier/channel) mechanism is used

    :markdown
        ```javascript
            // destroy an object, given its identifier
            {
                "type": "factory/destroy",
                "identifier": "123e4567-e89b-12d3-a456-426655440000",
                "parameters": {
                    "parameter2": 0.3039989
                }
            }
        ```

    p Note that there may be parameters that only make sense on creation, control, destruction or any combination. This will be up to the factory channel to determine. A simple factory definition is used to publish available parameters for each channel.

    :markdown
        ```javascript
            // destroy an object, given its identifier
            {
                "type": "factory/setup",
                "channels": {
                    "channel1": {
                        "create": ["parameter1", "parameter2", "parameter3"],
                        "control": ["parameter2", "parameter3"],
                        "destroy": ["parameter4"]
                    },
                    "channel2": {
                        "create": ["parameter1"],
                        "control": ["parameter2", "parameter3"],
                        "destroy": ["parameter4", "parameter5"]
                    }
                }
            }
        ```

    h2 Sound Synthesis Control Data

    p When it comes to sound and music, the persistence of MIDI for sound control despite its limitations (7 bit depth for channel, pitch, small number of channels, limited control and after-touch etc...) shows the power of standardization. Although OSC has found a place in music its role is often as a low-level controller (frequencies, amplitudes, filter parameters...). It hasn't replaced MIDI, it has complemented it. The factory messaging pattern described above is a perfect fit for emulating and augmenting MIDI capabilities. MIDI channels map to the channel property of factory messages, while pitch and volume can be given as parameters, a MIDI note on message would translate to

    :markdown
        ```javascript
            {
                "type": "synth/create",
                "channel": "pad1",
                "identifier": "123e4567-e89b-12d3-a456-426655440000",
                "parameters": {
                    "pitch": "A#5",
                    "volume": 0.5433435,
                    "shine": 0.232838,
                    "attack": 0.642466
                }
            }
        ```

    p There are obvious advantages over MIDI here, channels can have meaningful names (and their number is not limited by the standard). Volume has float precision, pitch is a string which allows it to address non-western or micro-tonal pitching or raw frequencies, and additional parameters can be added to alter the synthesiser parameters for each individual note. MIDI control messages fit just as nicely.

    :markdown
        ```javascript
        // control
        {
            "type": "synth/control",
            "identifier": "123e4567-e89b-12d3-a456-426655440000",
            "parameters": {
                "pitch": "f_432"
                "intensity": 0.342342,
                "shine": 0.54345343
            }
        }
        ```

    p Note that a MIDI pitch bend can be obtained by sending control messages with a changing pitch parameter, or a bend parameter to specify a pitch offset parameter. MIDI note off messages map to factory object destruction, for example

    :markdown
        ```javascript

        // stop for a single note
        {
            "type": "synth/stop",
            "identifier": "123e4567-e89b-12d3-a456-426655440000",
            "parameters": {
                "release": 0.342342
            }
        }
        ```

    p This additional flexibility in defining a synthesizers attributes and control mechanism comes at a cost of complexity for the synthesizer itself. But it is a price worth paying. It is up to the synthesizers to document the parameters which they support (as described in the previous section), and up to the controller to adapt, the factory messaging pattern works and emulates MIDI, enhancing it in significant ways, most notably flexible individual note control.


    h2 Virtual Object Manipulation Control Data

    p Virtual object manipulation is of central importance to the Sonosthesia project, it is a complex emerging subject. There is little pre-existing work in terms of protocols describing them. The factory messaging pattern is applied here also, for describing contacts. The channel represents an object in the virtual world (sphere, teapot etc...). A contact is created when a foreign objects collides with the channel.

    :markdown
        ```javascript
        {
            "type": "contact/create",
            "channel": "sphere1",
            "identifier": "123e4567-e89b-12d3-a456-426655440000"
            "parameters": {
                "incidence": 0.1765,
                "velocity": 10.7534,
                "hardness": 0.3342
                "wood": 0.2325,
                "metal": 0.4592
            }
        }
        ```

    p There are two required parameters which are the #[b incidence] (see #[a(href="https://en.wikipedia.org/wiki/Angle_of_incidence_(optics)") angle of incidence]) and the velocity. Other parameters are defined by the surface properties of the colliding objects at the point of collision. These properties should have behavioural meaning, influencing contact mappings. They can be mapped from the color components or UV coordinates at the impact points or anything else, let your imagination run wild. Once the contact is initiated, it can persist if the colliders stay within a given range of each other, in order to emulate actions like scratching, scraping, rubbing. During that time the parameters can be constantly updated by factory control messages.

    :markdown
        ```javascript
        {
            "type": "contact/control",
            "identifier": "123e4567-e89b-12d3-a456-426655440000"
            "parameters": {
                "incidence": 0.4982,
                "velocity": 3.7534,
                "hardness": 0.6732
                "wood": 0.5312,
                "metal": 0.4232
            }
        }
        ```

    p Note as before the absence of the channel property, which is implied by the unique identifier. When the colliders overrun the set contact distance threshold, the contact is destroyed following the factory messaging pattern (note the negative velocity implying that the colliders are moving away from each other).

    :markdown
        ```javascript
        {
            "type": "contact/destroy",
            "identifier": "123e4567-e89b-12d3-a456-426655440000"
            "parameters": {
                "incidence": 0.4982,
                "velocity": -3.7534
            }
        }
        ```


    h2 Generic Control Data

    p Having a multipurpose generic control message is very useful. It simplifies mappings between different domains, these messages can be used both as input to or output from components. Control messages are assigned a #[b group], a #[b descriptors] and a #[b value].

    :markdown
        ```javascript
        // set descriptor2 with 4-vector for subgroup1 of group2
        {
            "type": "control/continuous",
            "group": "group1"
            "descriptor": "descriptor2",
            "value": 0.32352
        }
        ```

    p The group defines what objects the control should be applied to, and descriptor defines how the values should be used to change these objects. Groups can be nested (to arbitrary levels), giving them a hierarchy. For example group #[b group1/subgroup1] belongs to group #[b group1]. Controlling a group will also affect all descendant groups. Parameter values can be be arrays or maps.

    :markdown
        ```javascript
        // set shine and rgba (with 4-vector) for subgroup1 of group2
        {
            "type": "control/continuous",
            "group": "group2/subgroup1"
            "parameters": {
                "rgba": [0.32352, 0.54322, 0.23533, 0.35747],
                "shine": 0.3423
        }

        // set rgba/r value for group2
        {
            "type": "control/continuous",
            "group": "group2"
            "descriptor": "rgba/r",
            "value": 0.32352
        }
        ```

    p This simple message format can be also used for discrete events, simply by changing #[b control/continuous] to #[b control/event]. In this case the #[b value] field becomes optional, this simple mechanism is surprisingly versatile.

    :markdown
        ```javascript
        // as simple as it gets
        {
            "type": "control/event",
            "group": "group1"
            "descriptor": "jump"
        }

        // creating a switch control/event
        {
            "type": "control/event",
            "group": "group2"
            "descriptor": "switch",
            "value": 3
        }
        ```

    h1 Standards for Cross-Domain Mappings

    p The core of Sonosthesia is to create mappings between different domains. Control pipelines of arbitrary complexity can be put in place, by mapping control streams from one component/domain to the next. At each step control stream can be piped into another component, or several, or looped back to the first component, creating an infinite control loop. Defining how these mappings are made is a crucial aspect of the project. Striking the right balance between simplicity, flexibility and domain-specific semantics is key.


    h2 Contacts as Sound Synthesis Controllers

    h2 Visual Attributes as Cues for Sonic Properties

    h2 Sound Analysis Data as Generic Controller

